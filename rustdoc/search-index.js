var searchIndex = {};
searchIndex["adapton"] = {"doc":"","items":[[0,"macros","adapton","",null,null],[3,"ProgPt","adapton::macros","",null,null],[12,"symbol","","",0,null],[5,"my_hash","","",null,{"inputs":[{"name":"t"}],"output":{"name":"u64"}}],[5,"my_hash_n","","",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"u64"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"progpt"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"progpt"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"progpt"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"engine","adapton","Adapton's core calculus, implemented as a runtime library.  We implement two versions of this interface, which we refer to as _engines_: The **naive engine** and the **DCG engine**, implemented based on the algorithms from the Adapton papers.",null,null],[3,"Name","adapton::engine","*Names*: First-class data that identifies a mutable cell (see `cell`) or a thunk (see `thunk`).  When a name identifies different content over time, it describes *where* incremental changing is occurring, relative to other (unaffected) parts of data structures or computations.",null,null],[3,"Flags","","Flags control runtime behavior of the DCG.",null,null],[12,"use_purity_optimization","","",1,null],[12,"ignore_nominal_use_structural","","Ignore the `Nominal` `ArtIdChoice`, and use `Structural` behavior instead",1,null],[12,"check_dcg_is_wf","","After each Adapton operation, check that the DCG is well-formed",1,null],[12,"write_dcg","","Within each well-formedness check, write the DCG to the local filesystem",1,null],[12,"gmlog_dcg","","Deprecated: At certain points in the Engine's code, write state changes as graph-movie output TODO: To be replaced with DCG reflection, and reflection-to-filesystem logic.",1,null],[3,"DCG","","*(DCG) Demanded Computation Graph*: The cache of past computation.",null,null],[12,"flags","","",2,null],[3,"Cnt","","*Engine Counts*: Metrics that reflect the time and space costs of the engine.",null,null],[12,"create","","Number of DCG nodes created",3,null],[12,"eval","","Number of DCG nodes evaluated",3,null],[12,"dirty","","Number of DCG nodes marked as dirty",3,null],[12,"clean","","Number of DCG nodes reverted from dirty to clean",3,null],[12,"stack","","Maximum height of the DCG node stack.  This stack is pushed when DCG nodes are evaluated, and popped when they complete.",3,null],[3,"Art","","*Articulations:* for incrementally-changing data/computation.",null,null],[4,"Engine","","The engine API works in two modes: `Naive` and `DCG`. A `Naive` engine is stateless, whereas the `DCG` is stateful.",null,null],[13,"DCG","","",4,null],[13,"Naive","","",4,null],[4,"ArtIdChoice","","An `ArtIdChoice` choses between `Eager`, `Structural` and `Nominal` identities for articulation points introduced by `thunk`.",null,null],[13,"Eager","","Eagerly produces an `Art` that merely consists of an `Rc`; no additional indirection is needed/used.",5,null],[13,"Structural","","Identifies an `Art` based on hashing content (e.g., `prog_pt` for code and argument(s)).",5,null],[13,"Nominal","","Identifies an `Art` based on a programmer-chosen name.",5,null],[5,"name_unit","","Create a name from unit, that is, create a \"leaf\" name.",null,{"inputs":[],"output":{"name":"name"}}],[5,"name_pair","","Create one name from two (binary name composition)",null,{"inputs":[{"name":"name"},{"name":"name"}],"output":{"name":"name"}}],[5,"name_of_usize","","Create a name from a `usize`",null,{"inputs":[{"name":"usize"}],"output":{"name":"name"}}],[5,"name_of_isize","","Create a name from a `isize`",null,{"inputs":[{"name":"isize"}],"output":{"name":"name"}}],[5,"name_of_string","","Create a name from a `string`",null,{"inputs":[{"name":"string"}],"output":{"name":"name"}}],[5,"name_of_str","","Create a name from a `str`",null,{"inputs":[{"name":"str"}],"output":{"name":"name"}}],[5,"name_fork","","Create two names from one",null,null],[5,"name_fork3","","Create three names from one",null,null],[5,"name_fork4","","Create four names from one",null,null],[5,"ns","","Creates or re-enters a given namespace; performs the given computation there.",null,{"inputs":[{"name":"name"},{"name":"f"}],"output":{"name":"t"}}],[5,"structural","","Enters a special \"namespace\" where all name uses are ignored; instead, Adapton uses structural identity.",null,{"inputs":[{"name":"f"}],"output":{"name":"t"}}],[5,"put","","Creates an unnamed, immutable reference cell (an eager `Art<_>`) whose content may not change over time.",null,{"inputs":[{"name":"t"}],"output":{"name":"art"}}],[5,"cell","","Creates a named reference cell (an eager `Art<_>`) whose content can change over time.",null,{"inputs":[{"name":"name"},{"name":"t"}],"output":{"name":"art"}}],[5,"set","","Mutates a mutable articulation.",null,{"inputs":[{"name":"art"},{"name":"t"}],"output":null}],[5,"thunk","","Allocates a thunk, an `Art<T>` that consists of a suspended computation that produces a value of type `T`.",null,{"inputs":[{"name":"artidchoice"},{"name":"progpt"},{"name":"rc"},{"name":"arg"},{"name":"spurious"}],"output":{"name":"art"}}],[5,"force","","Demands and observes the value of an `&Art<T>`, returning a (cloned) value of type `T`.",null,{"inputs":[{"name":"art"}],"output":{"name":"t"}}],[0,"reflect","","Reflects the DCG engine, including both the effects of the programs running in it, and the internal effects of the engine cleaning and dirtying the DCG.  For the latter effects, see the `trace` module.",null,null],[3,"Loc","adapton::engine::reflect","Reflected version of `engine::Loc` A `Loc` is a particular template for a `Name`: It is a path (a possibly-empty list of `Name`s), followed by a distinguished `Name`.  A `Loc` can be thought of roughly like a file path in UNIX (but Adapton has nothing to do with files, or with UNIX, directly).",null,null],[12,"path","","The path of the `Loc` is a list of `Name`s.",6,null],[12,"name","","The distinguished `Name` of the `Loc` (must be unique in the path).",6,null],[3,"Succ","","Reflected version of `engine::Succ`.  Unlike the real engine's `Succ` type, this version stores a reflected value (of type `Val`).",null,null],[12,"dirty","","Dirty invariant: If this edge is dirty, then all predecessors of the edge are dirty too.",7,null],[12,"loc","","The target of the outgoing `Effect`",7,null],[12,"effect","","The effect: either producing or consuming articulated content",7,null],[12,"value","","The value either produced or consumed by this `Effect`",7,null],[12,"is_dup","","Duplicate edge invariant: If this edge is a duplicate according to this flag, then it is preceded by an edge with the same effect `effect`, targeting the same location `loc`. Furthermore, because of the (precise naming) semantics of Adapton and its programs, the observed value `value` and `dirty` statuses are always the same across duplicated edges.  Hence, the engine does not store these duplicate edges: They are completely redundant.",7,null],[3,"Pred","","Reflected version of `engine::Pred`",null,null],[12,"loc","","The predecessor of the node in question",8,null],[12,"effect","","The effect that the predecessor has done to the node in question",8,null],[3,"CompNode","","Reflected version of `engine::CompNode`.  Stores a reflected value of type `Option<Val>`, which is `None` when the node has not yet been executed, and `Some(_)` otherwise.",null,null],[12,"preds","","",9,null],[12,"succs","","",9,null],[12,"prog_pt","","",9,null],[12,"value","","",9,null],[3,"RefNode","","Reflected version of `engine::MutNode`.  Stores a reflected value of type `Val`.",null,null],[12,"preds","","",10,null],[12,"value","","",10,null],[3,"PureNode","","Reflected version of `engine::PureNode`.  Stores a reflected value of type `Val`.",null,null],[12,"value","","",11,null],[3,"Frame","","Reflected version of `engine::Frame`.",null,null],[12,"loc","","",12,null],[12,"succs","","",12,null],[3,"DCG","","Reflected version of `engine::DCG`.",null,null],[12,"table","","The current memo table, mapping `Loc`s to `Node`s.",13,null],[12,"stack","","A stack of `Frame`s, which store the currently-executing nodes, and their outgoing edges thus far.",13,null],[12,"path","","A list of `Name`s, which is extended for nested regions of code by the `ns` (namespace) combinator.  This path variable determines the path for each allocated `Loc`.",13,null],[4,"Val","","Reflected value; Gives a syntax for inductive data type constructors (`Constr`), named articulations (`Art`) and primitive data (`Data`).  All values in the engine (including the values of nodes, and the values stored on edges) are represented with this reflected `Val` type.  Primarily, this distinction between actual Rust values and this type is what makes the DCG engine \"reflected\" by the definitions in this module, and not identical to them.",null,null],[13,"Constr","","Constructor, with a sequence of value parameters.",14,null],[13,"Tuple","","A tuple of values (like a constructor, but without a constructor name). Can be seen as a special case of `Constr`.",14,null],[13,"Vec","","A list of values (like a tuple, but parsed and printed differently). Can be seen as a special case of `Constr`.",14,null],[13,"Struct","","Constructor with a sequence of fields (name-value pairs) as parameters.",14,null],[13,"Art","","Named articulation, and its content (an `Art` is either a named value, or a named computation).",14,null],[13,"Name","","First-class `Name` value.",14,null],[13,"Const","","Primitive, immutable data.",14,null],[13,"ValTODO","","Temporary; for marking places in code where we should produce a value, but don't yet have a good way to do so.",14,null],[4,"Const","","Primitive constants",null,null],[13,"Num","","Integers",15,null],[13,"Nat","","Natural numbers",15,null],[13,"String","","Strings",15,null],[4,"ArtContent","","The content of an articulation: Either a cell holding a value, or a thunk that has optionally produced a value.",null,null],[13,"Val","","The `Art` consists of a ref cell holding a value",16,null],[13,"Comp","","The `Art` consists of a thunk that, when forced, computes a value",16,null],[13,"Unknown","","`Unknown` content means that it has not yet dereferenced by any reflective process.  A reflective process dereferences an `Art` by using a reflected `DCG` to map this `Art`'s `Loc` to a `Node`.  This node gives one of the two known cases (`Val` or `Comp`), above, depending on whether it is a `RefNode` or a `CompNode`.",16,null],[4,"Effect","","Reflected version of `engine::Effect`",null,null],[13,"Force","","The effect consists of a thunk observing the value of another thunk or reference cell.  That is, the effect consists of **consuming** a value, by demanding its production.",17,null],[13,"Alloc","","The effect consists of a thunk allocating a value or thunk at a particular name.  That is, the effect consists of **producing** a value or computation.  If this content differs, then the allocation is a **reallocation**, and the engine dirties the old observers and allocators of the preceding content.",17,null],[4,"Node","","Reflected version of `engine::Node`.  Unlike the real engine, these nodes are not parameterized by a value type.  Instead, their values are all reflected into type `Val`.",null,null],[13,"Comp","","",18,null],[13,"Ref","","",18,null],[13,"Pure","","",18,null],[5,"succs_of_node","","Get the `Succ`s of a `Node`, if they are defined.",null,{"inputs":[{"name":"node"}],"output":{"name":"option"}}],[5,"preds_of_node","","Get the `Pred`s of a `Node`, if they are defined.",null,{"inputs":[{"name":"node"}],"output":{"name":"option"}}],[5,"string_of_name","","See doc for `write_name`. Returns this output as a string.",null,{"inputs":[{"name":"name"}],"output":{"name":"string"}}],[5,"string_of_path","","See doc for `write_path`. Returns this output as a string.",null,{"inputs":[{"name":"path"}],"output":{"name":"string"}}],[5,"string_of_loc","","See doc for `write_loc`. Returns this output as a string.",null,{"inputs":[{"name":"loc"}],"output":{"name":"string"}}],[5,"write_name","","Write a concise human-readable version of the name (not the verbose, machine-parsable `Debug` version).",null,{"inputs":[{"name":"w"},{"name":"name"}],"output":null}],[5,"write_path","","Write a concise human-readable version of the path (not the verbose, machine-parsable `Debug` version).",null,{"inputs":[{"name":"w"},{"name":"path"}],"output":null}],[5,"write_loc","","Write a concise human-readable version of the location (not the verbose, machine-parsable `Debug` version).  ",null,{"inputs":[{"name":"w"},{"name":"loc"}],"output":null}],[5,"reflect_val","","_Rust data and articulation reflection_: Transform any(*) Rust data that derives `Debug` into a reflected `Val`.  ",null,{"inputs":[{"name":"v"}],"output":{"name":"val"}}],[5,"dcg_reflect_now","","Reflect the DCG's internal structure now.  Does not reflect any engine effects over this DCG (e.g., no cleaning or dirtying), just the _program effects_ recorded by the DCG's structure. Returns None if the engine is `Naive` and thus has no reflected state whatsoever.",null,{"inputs":[],"output":{"name":"option"}}],[5,"dcg_reflect_begin","","Begin recording (reflections of) DCG effects.  See `dcg_reflect_end()`.",null,{"inputs":[],"output":null}],[5,"dcg_reflect_end","","Stop recording (reflections of) DCG effects, and return them as a forrest (of DCG traces).  See `dcg_reflect_begin()`.",null,{"inputs":[],"output":{"name":"vec"}}],[0,"trace","","Gives effects and traces for cleaning and dirtying, the engine's internal DCG traversal/processing.  By contrast, the enclosing module (`reflect`) only gives reflected versions of the DCG itself, not changes that the engine makes to it.",null,null],[3,"Edge","adapton::engine::reflect::trace","An edge in the DCG, representing an effect of the incremental program.",null,null],[12,"loc","","The source of the directed edge; it is actively _doing_ the effect of `succ.effect` to `succ.loc`.  `None` means the doer is the **editor**, who is not identified by any location. (The editor is not a node in the DCG, but rather, an actor operating outside of it).",19,null],[12,"succ","","The effect and target of the directed edge.",19,null],[3,"Trace","","`DCGTrace`: A Rose-tree of DCG edge-effects.  This tree structure allows the effects to have a a \"time interval\" that nests around and within the time intervals of other effects.",null,null],[12,"effect","","The DCG effect (e.g., Alloc(MatchDiff), Dirty, Clean, etc.)",20,null],[12,"edge","","The DCG edge on which this DCG effect takes place",20,null],[12,"extent","","The DCG effects that occur subordinately as a result of this effect. (They begin after this effect begins, and the end before this effect ends).",20,null],[4,"AllocCase","","Distinguish fresh allocations from those that reuse an existing location.",null,null],[13,"LocFresh","","The allocation was **created** fresh; it was **not** reused.",21,null],[13,"LocExists","","The allocation matched the location of a prior allocation. its content may or may not also match.  The `bool` indicates the two cases: `true` means same content, `false` means changed content.",21,null],[4,"ChangeFlag","","",null,null],[13,"ContentDiff","","",22,null],[13,"ContentSame","","",22,null],[4,"AllocKind","","Distinguish ref cell allocations from thunk allocations",null,null],[13,"RefCell","","",23,null],[13,"Thunk","","",23,null],[4,"ForceCase","","When the program `force`s a computation, either the cache is either empty (`CacheMiss`) or non-empty (`CacheHit`).  The cached value may not be consistent without a cleaning.  When the program `force`s a reference cell, it simply gets the current value.",null,null],[13,"CompCacheMiss","","The DCG has no cached value for this computation; no prior computation will be reused.",24,null],[13,"CompCacheHit","","The DCG has a cached value for this computation; it may not be consistent without a cleaning first.",24,null],[13,"RefGet","","The forced node is a ref cell with a (mutable) value, and hence, no computation was necessary.  The `force` simply gets the current value.",24,null],[4,"Effect","","The effects of the DCG (including cleaning and dirtying) on one of its edges.",null,null],[13,"Alloc","","Wrapper for Effect::Alloc; transition to DCG after the alloc.",25,null],[13,"Force","","Wrapper for Effect::Force; transition to DCG after the force.",25,null],[13,"Dirty","","Transition to this edge as **dirty** (potentially inconsistent). This transition may consist of marking other edges dirty.  The DCG's invariant about dirty edges is simple: If an edge is dirty, then all edges that force (demand/observe) the source of that edge must also be dirty.  This transitive closure property ensures that we do not accidentally reuse stale cached values by mistake (a dirty edge will always witness a potentially stale cached value).",25,null],[13,"CleanRec","","Clean this edge, marking it **not dirty**, or equivalently, **definitely consistent**. Cleaning an edge consists of processing the edge's dirty transitive dependencies, if any. Recursively, this processing may consist of marking other edges clean (`CleanEdge`), and/or, removing edges (`Remove`) and replacing them via reevaluation under the current DCG state (`CleanEval`).  ",25,null],[13,"CleanEdge","","Transition to this edge as **clean** (definitely consistent), after doing a recursive cleaning of its dependencies and finding that they are clean.  This effect is mutually-exclusive with `CleanEval`, which occurs when `CleanEdge` **cannot** occur on an edge that is being recursively cleaned (via `CleanRec`).",25,null],[13,"CleanEval","","Re-evaluate the previously-forced thunk that is the target of this edge, to clean it.  This effect is mutually-exclusive with `CleanEdge`.  It occurs when `CleanEdge` cannot occur.",25,null],[13,"Remove","","Transition to the DCG without this edge.  Perhaps it will be replaced via re-execution, sometime later.",25,null],[6,"Path","adapton::engine::reflect","A `Path` here is just a `Vec` of `Name`s",null,null],[8,"Reflect","","This trait consists of the ability for a reference to `Self` to produce a `T`.  Conceptually, that value of type T is the \"reflection\" of `Self`.  A large set of types in `engine` implement this trait for a particular type in this module, which represents its reflection.  The documentation of this module makes this correspondance clear.",null,null],[10,"reflect","","",26,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[0,"manage","adapton::engine","Operations that monitor and alter the active engine.  Incremental applications should not use these operations directly.",null,null],[5,"init_dcg","adapton::engine::manage","Initializes global state with a fresh DCG-based engine; returns the old engine. The DCG is the central implementation structure behind Adapton. At a high level, it consists of a data dependence graph (the \"demanded computation graph\"), and an associated memoization table.",null,{"inputs":[],"output":{"name":"engine"}}],[5,"init_naive","","Initializes global state with a (\"fresh\") Naive engine; returns the old engine. The naive engine is stateless, and performs no memoization and builds no dependence graphs. (Since the naive engine is stateless, every instance of the naive engine is equivalent to a \"fresh\" one).",null,{"inputs":[],"output":{"name":"engine"}}],[5,"use_engine","","Switch to using the given `Engine`; returns the `Engine` that was in use.",null,{"inputs":[{"name":"engine"}],"output":{"name":"engine"}}],[5,"init_engine","","alias for `use_engine`",null,{"inputs":[{"name":"engine"}],"output":{"name":"engine"}}],[5,"cnt","","Counts various engine cost metrics, returning a product of sums (`Cnt`)",null,null],[5,"engine_is_naive","","True iff the current engine is `Naive`",null,{"inputs":[],"output":{"name":"bool"}}],[5,"engine_is_dcg","","True iff the current engine is a `DCG`",null,{"inputs":[],"output":{"name":"bool"}}],[11,"eq","adapton::engine","",27,{"inputs":[{"name":"self"},{"name":"name"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"name"}],"output":{"name":"bool"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"name"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",27,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"engine"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"reflect","","",2,{"inputs":[{"name":"self"}],"output":{"name":"dcg"}}],[11,"hash","","",2,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"hash","","",5,null],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"artidchoice"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"artidchoice"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"artidchoice"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",3,null],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"cnt"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"cnt"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"cnt"}}],[11,"add","","",3,null],[11,"zero","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"art"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"art"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"self"},{"name":"art"}],"output":{"name":"bool"}}],[11,"hash","","",28,null],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"collections","adapton","",null,null],[4,"Dir2","adapton::collections","",null,null],[13,"Left","","",29,null],[13,"Right","","",29,null],[4,"List","","",null,null],[13,"Nil","","",30,null],[13,"Cons","","",30,null],[13,"Tree","","",30,null],[13,"Name","","",30,null],[13,"Art","","",30,null],[4,"Tree","","",null,null],[13,"Nil","","",31,null],[13,"Leaf","","",31,null],[13,"Bin","","",31,null],[13,"Name","","",31,null],[13,"Art","","",31,null],[4,"NameElse","","",null,null],[13,"Name","","",32,null],[13,"Else","","",32,null],[5,"list_gen","","",null,{"inputs":[{"name":"usize"},{"name":"g"}],"output":{"name":"l"}}],[5,"list_nil","","",null,{"inputs":[],"output":{"name":"l"}}],[5,"list_cons","","",null,{"inputs":[{"name":"x"},{"name":"l"}],"output":{"name":"l"}}],[5,"list_name","","",null,{"inputs":[{"name":"name"},{"name":"l"}],"output":{"name":"l"}}],[5,"list_art","","",null,{"inputs":[{"name":"art"}],"output":{"name":"l"}}],[5,"list_name_art_op","","",null,{"inputs":[{"name":"option"},{"name":"l"}],"output":{"name":"l"}}],[5,"list_name_op","","",null,{"inputs":[{"name":"option"},{"name":"l"}],"output":{"name":"l"}}],[5,"list_map_lazy","","Lazily maps the list, guided by names in input list. Creates lazy named thunks in output for each name in input.",null,{"inputs":[{"name":"le"},{"name":"rc"}],"output":{"name":"li"}}],[5,"list_filter_lazy","","Lazily filters the list, guided by names in input list. Creates lazy named thunks in output for each name in input.",null,{"inputs":[{"name":"le"},{"name":"rc"}],"output":{"name":"li"}}],[5,"list_filter_eager","","Eagerly filters the list, guided by names in input list. Memoizes recursion for each name in input.",null,{"inputs":[{"name":"le"},{"name":"rc"}],"output":{"name":"li"}}],[5,"list_map_eager","","Eagerly maps the list. Uses (eager) memoization for each name in `l`.",null,{"inputs":[{"name":"le"},{"name":"rc"}],"output":{"name":"li"}}],[5,"list_map_eager2","","Eagerly maps the list.  Uses (eager) memoization for each name in `l`.  Unlike list_map_eager, it allocates a reference cell for each name, separate from the memoized thunk for the recursive call.",null,{"inputs":[{"name":"le"},{"name":"rc"}],"output":{"name":"li"}}],[5,"list_reverse","","Eagerly maps the list. Uses (eager) memoization for each name in `l`.",null,{"inputs":[{"name":"le"},{"name":"li"}],"output":{"name":"li"}}],[5,"list_fold","","Ignores names; performs no memoization; use tree_fold_* for lists that could be long.",null,{"inputs":[{"name":"l"},{"name":"res"},{"name":"rc"}],"output":{"name":"res"}}],[5,"list_is_empty","","",null,{"inputs":[{"name":"l"}],"output":{"name":"bool"}}],[5,"list_pop","","",null,null],[5,"list_push","","",null,{"inputs":[{"name":"l"},{"name":"x"}],"output":{"name":"l"}}],[5,"list_append","","",null,{"inputs":[{"name":"l"},{"name":"l"}],"output":{"name":"l"}}],[5,"map_empty","","",null,{"inputs":[],"output":{"name":"m"}}],[5,"map_update","","",null,{"inputs":[{"name":"m"},{"name":"dom"},{"name":"cod"}],"output":{"name":"m"}}],[5,"map_find","","",null,{"inputs":[{"name":"m"},{"name":"dom"}],"output":{"name":"option"}}],[5,"map_fold","","",null,{"inputs":[{"name":"m"},{"name":"res"},{"name":"rc"}],"output":{"name":"res"}}],[5,"tree_fold_seq","","",null,{"inputs":[{"name":"t"},{"name":"dir2"},{"name":"res"},{"name":"rc"},{"name":"rc"},{"name":"rc"}],"output":{"name":"res"}}],[5,"tree_fold_up","","Fold over the structure of the tree, with results flowing up, from `nil` and `leaf` cases to the binary cases of `bin` and `name`. This folding pattern is suitable for aggregating the leaf elements via an associative operation, such as a monoid (e.g., counting, addition, multiplication, maximum, minimum, etc.). See `monoid_of_tree` for a wrapper function that offers this usage. This folding pattern is also suitable for producing copies of the tree's structure.",null,{"inputs":[{"name":"t"},{"name":"rc"},{"name":"rc"},{"name":"rc"},{"name":"rc"}],"output":{"name":"res"}}],[5,"tree_fold_up_nm_dn","","Like `tree_fold_up`, except that names from `name` nodes are passed down, to the next `nil` and `leaf` cases. The name from a `name` constructor associates to its right subtree, which is consistent with a left-to-right, in-order traversal of the tree. The recursive argument `nm` provides the name for the left subtree, if any.",null,{"inputs":[{"name":"t"},{"name":"option"},{"name":"rc"},{"name":"rc"},{"name":"rc"},{"name":"rc"}],"output":{"name":"res"}}],[5,"tree_of_list","","",null,{"inputs":[{"name":"dir2"},{"name":"l"}],"output":{"name":"t"}}],[5,"tree_of_list_rec","","",null,null],[5,"list_of_tree","","List the leaf elements and names of a tree, in the given order, via a sequential, in-order traversal. Direction `Dir2::Left` lists elements from left to right. (Leftmost elements are in the head of the list). Direction `Dir2::Right` lists elements from right to left. (Rightmost elements are in the head of the list). Preserves the order of elements, up to `dir`, and the names in the tree.",null,{"inputs":[{"name":"t"},{"name":"dir2"}],"output":{"name":"l"}}],[5,"filter_list_of_tree","","Filter the leaf elements of a tree using a user-provided predicate, `pred`. Returns a list of the elements for which the predicate returns `true`. Retains exactly one name between any two elements that, in the original sequence, were separated by a name. Does not insert names that were not present in the original sequence.",null,{"inputs":[{"name":"t"},{"name":"box"}],"output":{"name":"l"}}],[5,"filter_tree_of_tree","","Filter the leaf elements of a tree using a user-provided predicate, `pred`. Returns a tree of the elements for which the predicate returns `true`. Retains all names from the original tree, even if they merely name empty sub-trees.",null,{"inputs":[{"name":"te"},{"name":"box"}],"output":{"name":"ti"}}],[5,"monoid_of_tree","","Aggregates the leaf elements of a tree using a user-defined monoid.  The monoid consists of an identity element `id_elm` and binary operation over leaf values `bin_op`. Derived from `tree_fold_up`.",null,{"inputs":[{"name":"te"},{"name":"x"},{"name":"rc"}],"output":{"name":"x"}}],[5,"eager_tree_of_tree","","Produces a tree with the same structure as its input, but without any articulations.  Useful for `println`-style debugging, and for equality comparisons across distinct engine implementations (e.g., to verify the DCG-based engine).",null,{"inputs":[{"name":"te"}],"output":{"name":"ti"}}],[5,"prune_tree_of_tree","","Produces a tree with the same structure as its input, but without any empty subtrees, and with articulations placed around the subtrees of named binary nodes.",null,{"inputs":[{"name":"te"}],"output":{"name":"ti"}}],[5,"list_demand","","Calls `vec_of_list` with the given `demand`",null,{"inputs":[{"name":"l"},{"name":"usize"}],"output":{"name":"vec"}}],[5,"vec_of_list","","Attempts to force `limit` number of `Cons` cells of the list, gathering these elements and any interposed `Name`s.",null,{"inputs":[{"name":"l"},{"name":"option"}],"output":{"name":"vec"}}],[5,"list_of_vec","","Constructs a linked list that consists of elements and names, as given by the input vector (in that order). Not incremental; used only for setting up inputs for tests.",null,{"inputs":[{"name":"vec"}],"output":{"name":"l"}}],[5,"list_merge","","Produce a lazy list that consists of merging two input lists. The output is lazy to the extent that the input lists contain `name`s. When the input lists are each sorted according to `Ord`; the output is sorted.",null,{"inputs":[{"name":"option"},{"name":"l"},{"name":"option"},{"name":"l"}],"output":{"name":"l"}}],[5,"mergesort_list_of_tree","","Demand-driven sort over a tree's leaves, whose elements are `Ord`. To the extent that the tree contains `name`s, the output is lazy, and thus sorts on-demand. Demanding the first element is `O(n)` for a tree with `n` leaves. Demanding the next element requires more comparisons, but fewer than the first element. Demanding the last element requires only `O(1)` comparisons. In total, the number of comparisons to demand the entire output is, as usual, `O(n ° log(n))`.",null,{"inputs":[{"name":"t"}],"output":{"name":"l"}}],[5,"mergesort_list_of_tree2","","Demand-driven sort over a tree's leaves, whose elements are `Ord`. To the extent that the tree contains `name`s, the output is lazy, and thus sorts on-demand. Demanding the first element is `O(n)` for a tree with `n` leaves. Demanding the next element requires more comparisons, but fewer than the first element. Demanding the last element requires only `O(1)` comparisons. In total, the number of comparisons to demand the entire output is, as usual, `O(n ° log(n))`.",null,{"inputs":[{"name":"t"},{"name":"option"}],"output":{"name":"l"}}],[5,"mergesort_list_of_tree3","","Demand-driven sort over a tree's leaves, whose elements are `Ord`. To the extent that the tree contains `name`s, the output is lazy, and thus sorts on-demand. Demanding the first element is `O(n)` for a tree with `n` leaves. Demanding the next element requires more comparisons, but fewer than the first element. Demanding the last element requires only `O(1)` comparisons. In total, the number of comparisons to demand the entire output is, as usual, `O(n ° log(n))`.",null,{"inputs":[{"name":"t"},{"name":"option"}],"output":{"name":"l"}}],[5,"list_merge_wrapper","","",null,{"inputs":[{"name":"option"},{"name":"l"},{"name":"option"},{"name":"l"}],"output":{"name":"l"}}],[0,"trie","","",null,null],[3,"Meta","adapton::collections::trie","Metadata held by the root node.",null,null],[12,"min_depth","","",33,null],[4,"Trie","","Probablistically Balanced Trie Rough implementation of probabilistic tries from OOPSLA 2015 paper.",null,null],[13,"Nil","","",34,null],[13,"Leaf","","",34,null],[13,"Bin","","",34,null],[13,"Root","","",34,null],[13,"Name","","",34,null],[13,"Art","","",34,null],[5,"trie_fold","","",null,{"inputs":[{"name":"t"},{"name":"res"},{"name":"rc"}],"output":{"name":"res"}}],[5,"trie_of_list","","",null,{"inputs":[{"name":"l"}],"output":{"name":"t"}}],[6,"Set","","",null,null],[17,"PLACEMENT_SEED","","",null,null],[8,"MetaT","","",null,null],[10,"hash_seeded","","",35,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[8,"TrieIntro","","",null,null],[10,"nil","","",36,{"inputs":[{"name":"bs"}],"output":{"name":"self"}}],[10,"leaf","","",36,{"inputs":[{"name":"bs"},{"name":"x"}],"output":{"name":"self"}}],[10,"bin","","",36,{"inputs":[{"name":"bs"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"root","","",36,{"inputs":[{"name":"meta"},{"name":"self"}],"output":{"name":"self"}}],[10,"name","","",36,{"inputs":[{"name":"name"},{"name":"self"}],"output":{"name":"self"}}],[10,"art","","",36,{"inputs":[{"name":"art"}],"output":{"name":"self"}}],[10,"empty","","",36,{"inputs":[{"name":"meta"}],"output":{"name":"self"}}],[10,"singleton","","",36,{"inputs":[{"name":"meta"},{"name":"name"},{"name":"x"}],"output":{"name":"self"}}],[10,"extend","","",36,{"inputs":[{"name":"name"},{"name":"self"},{"name":"x"}],"output":{"name":"self"}}],[8,"TrieElim","","",null,null],[10,"find","","",37,{"inputs":[{"name":"self"},{"name":"x"},{"name":"i64"}],"output":{"name":"option"}}],[10,"is_empty","","",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"split_atomic","","",37,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"elim","","",37,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"rootc"},{"name":"namec"}],"output":{"name":"res"}}],[10,"elim_arg","","",37,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"rootc"},{"name":"namec"}],"output":{"name":"res"}}],[10,"elim_ref","","",37,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"rootc"},{"name":"namec"}],"output":{"name":"res"}}],[8,"SetIntro","","",null,null],[10,"empty","","",38,{"inputs":[],"output":{"name":"self"}}],[10,"add","","",38,{"inputs":[{"name":"self"},{"name":"x"}],"output":{"name":"self"}}],[8,"SetElim","","",null,null],[10,"mem","","",39,{"inputs":[{"name":"self"},{"name":"x"}],"output":{"name":"bool"}}],[10,"fold","","",39,{"inputs":[{"name":"self"},{"name":"res"},{"name":"rc"}],"output":{"name":"res"}}],[0,"raz","adapton::collections","Random Access Zipper (RAZ). Purely functional sequences with global access (via a balanced tree structure) and simple local edits (via a zipper structure).",null,null],[3,"Punc","adapton::collections::raz","Punctuation: Information that is interposed between each run of elements, and sometimes before and after them.  The RAZ uses user-chosen levels to probabilistically balance the Tree form. The RAZ uses the Name to identify cached computations in Adapton.",null,null],[12,"level","","",40,null],[12,"name","","",40,null],[3,"Zip","","The Zipper form consists of element sequences before (to the left of) and after (to the right of) a distinguished punctuation point in the sequence.",null,null],[4,"Tree","","A binary tree with vector leaves (aka, a \"rope\"), balanced probabilistically.",null,null],[13,"Nil","","Invariant: Nil only appears in certain edge positions",41,null],[13,"Leaf","","Invariant: Each element run in a Leaf is interposed between two `Punc`s",41,null],[13,"Bin","","(Non-trivial) Inductive case: Two balanced sub-trees, interposed with punctuation. Invariant: For balance, every Bin node in left/right subtrees has a equal-or-lower level.",41,null],[13,"Art","","(Trivial) Inductive case: An Adapton articulation.",41,null],[4,"Dir","","Distinguishes left (`L`) and right (`R`) traversal orders for various operations involving trees.",null,null],[13,"L","","",42,null],[13,"R","","",42,null],[4,"Edit","","An O(1)-sized change to the zipper: a single element insertion, replacement, removal; or, a local cursor movement by one element in either direction.",null,null],[13,"Insert","","",43,null],[13,"Replace","","",43,null],[13,"Remove","","",43,null],[13,"Move","","",43,null],[5,"zip_empty","","A zipper that consists of zero elements (and exactly one punctuation `p`).",null,{"inputs":[{"name":"punc"}],"output":{"name":"zip"}}],[5,"tree_empty","","A tree that consists of zero elements (and exactly one punctuation `p`).",null,{"inputs":[{"name":"punc"}],"output":{"name":"tree"}}],[5,"zip_insert","","Transform the zipper, inserting element `x` in the given direction `d`. The optional punctuation `p` follows the inserted element, in the given direction.",null,{"inputs":[{"name":"zip"},{"name":"dir"},{"name":"x"},{"name":"option"}],"output":{"name":"zip"}}],[5,"zip_edit","","Perform the given edit, in the given direction, at the current focus of the given zipper. The zipper is taken because its head vectors may be mutated, e.g., to insert or remove elements.",null,{"inputs":[{"name":"zip"},{"name":"edit"}],"output":{"name":"zip"}}],[5,"tree_append","","Appends the sequences of two trees",null,{"inputs":[{"name":"tree"},{"name":"tree"}],"output":{"name":"tree"}}],[5,"tree_of_zip","","Unfocuses the zipper into a tree form",null,{"inputs":[{"name":"zip"}],"output":{"name":"tree"}}],[5,"mergesort_eager","","Merge-sort the elements of the given tree, producing another tree, in ascending order (when `d = Dir::L`) or descending order (when `d = Dir::R`).",null,{"inputs":[{"name":"option"},{"name":"tree"},{"name":"dir"}],"output":{"name":"tree"}}],[11,"eq","","",40,{"inputs":[{"name":"self"},{"name":"punc"}],"output":{"name":"bool"}}],[11,"ne","","",40,{"inputs":[{"name":"self"},{"name":"punc"}],"output":{"name":"bool"}}],[11,"hash","","",40,null],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",40,{"inputs":[{"name":"self"}],"output":{"name":"punc"}}],[11,"eq","","",41,{"inputs":[{"name":"self"},{"name":"tree"}],"output":{"name":"bool"}}],[11,"ne","","",41,{"inputs":[{"name":"self"},{"name":"tree"}],"output":{"name":"bool"}}],[11,"hash","","",41,null],[11,"fmt","","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",41,{"inputs":[{"name":"self"}],"output":{"name":"tree"}}],[11,"eq","","",44,{"inputs":[{"name":"self"},{"name":"zip"}],"output":{"name":"bool"}}],[11,"ne","","",44,{"inputs":[{"name":"self"},{"name":"zip"}],"output":{"name":"bool"}}],[11,"hash","","",44,null],[11,"fmt","","",44,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",44,{"inputs":[{"name":"self"}],"output":{"name":"zip"}}],[11,"eq","","",42,{"inputs":[{"name":"self"},{"name":"dir"}],"output":{"name":"bool"}}],[11,"hash","","",42,null],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",42,{"inputs":[{"name":"self"}],"output":{"name":"dir"}}],[11,"eq","","",43,{"inputs":[{"name":"self"},{"name":"edit"}],"output":{"name":"bool"}}],[11,"ne","","",43,{"inputs":[{"name":"self"},{"name":"edit"}],"output":{"name":"bool"}}],[11,"hash","","",43,null],[11,"fmt","","",43,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",43,{"inputs":[{"name":"self"}],"output":{"name":"edit"}}],[8,"ListIntro","adapton::collections","Types that can be created like a list of `X` are `ListIntro<X>`",null,null],[10,"nil","","Introduce an empty list",45,{"inputs":[],"output":{"name":"self"}}],[10,"cons","","Introduce a Cons cell",45,{"inputs":[{"name":"x"},{"name":"self"}],"output":{"name":"self"}}],[10,"name","","Introduce a Name \"cons\" cell",45,{"inputs":[{"name":"name"},{"name":"self"}],"output":{"name":"self"}}],[10,"art","","Introduce a list with an articulation that holds a list",45,{"inputs":[{"name":"art"}],"output":{"name":"self"}}],[11,"singleton","","Creates a singleton list. Derived from `cons` and `nil` introduction forms.",45,{"inputs":[{"name":"x"}],"output":{"name":"self"}}],[11,"name_art","","For `Some(nm)`, wraps the given list in `name` and `art` constructors for given name `nm`. For `None`, is the list identity function.",45,{"inputs":[{"name":"option"},{"name":"self"}],"output":{"name":"self"}}],[8,"ListElim","","Types that can be pattern-matched like a list of `X` are `ListElim<X>`. We consider iterators to be a similar (nearly analogous) trait. The key distinction here are that list elimination is a pattern-match used with (pure) recursion, as opposed to an imperative for-loop, as is typical of iteration; further, lists in Adapton contain data (of type `X`) and names (of type `Name`).",null,null],[10,"elim","","Eliminate a list with the given functions (for the pattern match arms) that handle the `nil`, `cons` and `name` cases. Eliminates the `art` case internally, by forcing the art and eliminating the resulting list with the given handler functions; forces multiple `art` cases, if need be.",46,{"inputs":[{"name":"self"},{"name":"nilf"},{"name":"consf"},{"name":"namef"}],"output":{"name":"res"}}],[10,"elim_arg","","Like `elim`, except that the functions are given an additional argument.  This variant is needed due to the move semantics of Rust. The argument is moved into the body of the activated handler function when it is applied.",46,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilf"},{"name":"consf"},{"name":"namef"}],"output":{"name":"res"}}],[11,"is_empty","","Tests if the list contains any `cons` cells. Derived from `elim`.",46,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_name","","Tests if the head of the list consists of a `name` constructor. Derived from `elim`.",46,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"RoseIntro","","Rose Trees: A tree with arbitrary branching at each node. See also, Definition 2 (page 2) of   *Parallel Implementation of Tree Skeletons*, by D.B. Skillicorn 1995.",null,null],[16,"List","","",47,null],[10,"leaf","","Introduce a leaf with exactly zero children",47,{"inputs":[{"name":"leaf"}],"output":{"name":"self"}}],[10,"branch","","Introduce a branch with zero or more subtrees",47,null],[10,"name","","Introduce a Named subtree",47,{"inputs":[{"name":"name"},{"name":"self"}],"output":{"name":"self"}}],[10,"art","","Introduce a list with an articulation that holds a list",47,{"inputs":[{"name":"art"}],"output":{"name":"self"}}],[8,"RoseElim","","Rose Trees: A tree with arbitrary branching at each node. See also, Definition 2 (page 2) of   *Parallel Implementation of Tree Skeletons*, by D.B. Skillicorn 1995.",null,null],[16,"Children","","",48,null],[10,"elim","","",48,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"leaffn"},{"name":"branchfn"},{"name":"namefn"}],"output":{"name":"res"}}],[8,"Level","","Levels for a probabilistically-balanced trees. For more details see Pugh and Teiltelbaum's POPL 1989 paper, and its \"Chunky List\" representation (*Incremental Computation via Function Caching*).",null,null],[10,"new","","",49,{"inputs":[{"name":"x"}],"output":{"name":"self"}}],[10,"bits","","",49,{"inputs":[],"output":{"name":"self"}}],[10,"zero","","",49,{"inputs":[],"output":{"name":"self"}}],[10,"inc","","",49,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"add","","",49,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"lte","","",49,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[10,"max_val","","",49,{"inputs":[],"output":{"name":"self"}}],[11,"max","","",49,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"TreeIntro","","Types that can be created like a (binary) tree with leaves of type `Leaf` are `TreeIntro<Leaf>`. We recognize that monoids are a nearly-analogous case; the key differences with monoids are that trees contain names (see `name` fn) and articulations (see `art` fn); further, the binary cases `name` and `bin` carry levels of type `Lev`, which helps establish and maintain balance.",null,null],[10,"nil","","",50,{"inputs":[],"output":{"name":"self"}}],[10,"leaf","","",50,{"inputs":[{"name":"leaf"}],"output":{"name":"self"}}],[10,"bin","","",50,{"inputs":[{"name":"lev"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"name","","",50,{"inputs":[{"name":"name"},{"name":"lev"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"art","","",50,{"inputs":[{"name":"art"}],"output":{"name":"self"}}],[8,"TreeElim","","",null,null],[10,"lev_of_tree","","",51,{"inputs":[{"name":"self"}],"output":{"name":"lev"}}],[10,"elim","","",51,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"}],"output":{"name":"res"}}],[10,"elim_ref","","",51,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"}],"output":{"name":"res"}}],[10,"elim_arg","","",51,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"}],"output":{"name":"res"}}],[10,"full_move","","",51,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"},{"name":"artc"}],"output":{"name":"res"}}],[11,"is_empty","","",51,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_nil","","",51,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"MapIntro","","",null,null],[10,"empty","","",52,{"inputs":[],"output":{"name":"self"}}],[10,"update","","",52,{"inputs":[{"name":"self"},{"name":"dom"},{"name":"cod"}],"output":{"name":"self"}}],[8,"MapElim","","",null,null],[10,"find","","",53,{"inputs":[{"name":"self"},{"name":"dom"}],"output":{"name":"option"}}],[10,"remove","","",53,null],[10,"fold","","",53,{"inputs":[{"name":"self"},{"name":"res"},{"name":"rc"}],"output":{"name":"res"}}],[10,"append","","",53,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"SetIntro","","",null,null],[10,"empty","","",54,{"inputs":[],"output":{"name":"self"}}],[10,"add","","",54,{"inputs":[{"name":"self"},{"name":"elm"}],"output":{"name":"self"}}],[10,"remove","","",54,{"inputs":[{"name":"self"},{"name":"elm"}],"output":{"name":"self"}}],[10,"union","","",54,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"inter","","",54,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"diff","","",54,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"SetElim","","",null,null],[10,"is_mem","","",55,{"inputs":[{"name":"self"},{"name":"elm"}],"output":{"name":"bool"}}],[10,"fold","","",55,{"inputs":[{"name":"self"},{"name":"res"},{"name":"f"}],"output":{"name":"res"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"dir2"}}],[11,"hash","","",29,null],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"dir2"}],"output":{"name":"bool"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",30,{"inputs":[{"name":"self"},{"name":"list"}],"output":{"name":"bool"}}],[11,"ne","","",30,{"inputs":[{"name":"self"},{"name":"list"}],"output":{"name":"bool"}}],[11,"hash","","",30,null],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"list"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",31,{"inputs":[{"name":"self"},{"name":"tree"}],"output":{"name":"bool"}}],[11,"ne","","",31,{"inputs":[{"name":"self"},{"name":"tree"}],"output":{"name":"bool"}}],[11,"hash","","",31,null],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"tree"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"nameelse"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"nameelse"}],"output":{"name":"bool"}}],[11,"ne","","",32,{"inputs":[{"name":"self"},{"name":"nameelse"}],"output":{"name":"bool"}}],[11,"hash","","",32,null],[11,"nil","","",30,{"inputs":[],"output":{"name":"self"}}],[11,"cons","","",30,{"inputs":[{"name":"x"},{"name":"self"}],"output":{"name":"self"}}],[11,"name","","",30,{"inputs":[{"name":"name"},{"name":"self"}],"output":{"name":"self"}}],[11,"art","","",30,{"inputs":[{"name":"art"}],"output":{"name":"self"}}],[11,"elim","","",30,{"inputs":[{"name":"self"},{"name":"nilf"},{"name":"consf"},{"name":"namef"}],"output":{"name":"res"}}],[11,"elim_arg","","",30,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilf"},{"name":"consf"},{"name":"namef"}],"output":{"name":"res"}}],[11,"empty","","",30,{"inputs":[],"output":{"name":"self"}}],[11,"update","","",30,{"inputs":[{"name":"self"},{"name":"dom"},{"name":"cod"}],"output":{"name":"self"}}],[11,"find","","",30,{"inputs":[{"name":"self"},{"name":"dom"}],"output":{"name":"option"}}],[11,"remove","","",30,null],[11,"fold","","",30,{"inputs":[{"name":"self"},{"name":"res"},{"name":"rc"}],"output":{"name":"res"}}],[11,"append","","",30,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"nil","","",31,{"inputs":[],"output":{"name":"self"}}],[11,"leaf","","",31,{"inputs":[{"name":"leaf"}],"output":{"name":"self"}}],[11,"bin","","",31,{"inputs":[{"name":"usize"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"name","","",31,{"inputs":[{"name":"name"},{"name":"usize"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"art","","",31,{"inputs":[{"name":"art"}],"output":{"name":"self"}}],[11,"elim_arg","","",31,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"}],"output":{"name":"res"}}],[11,"full_move","","",31,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"},{"name":"artc"}],"output":{"name":"res"}}],[11,"elim","","",31,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"}],"output":{"name":"res"}}],[11,"elim_ref","","",31,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"namec"}],"output":{"name":"res"}}],[11,"lev_of_tree","","",31,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"fmt","adapton::collections::trie","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",34,{"inputs":[{"name":"self"},{"name":"trie"}],"output":{"name":"bool"}}],[11,"ne","","",34,{"inputs":[{"name":"self"},{"name":"trie"}],"output":{"name":"bool"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"trie"}}],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",33,{"inputs":[{"name":"self"},{"name":"meta"}],"output":{"name":"bool"}}],[11,"ne","","",33,{"inputs":[{"name":"self"},{"name":"meta"}],"output":{"name":"bool"}}],[11,"hash","","",33,null],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"meta"}}],[11,"hash_seeded","","",33,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"nil","","",34,{"inputs":[{"name":"bs"}],"output":{"name":"self"}}],[11,"leaf","","",34,{"inputs":[{"name":"bs"},{"name":"x"}],"output":{"name":"self"}}],[11,"bin","","",34,{"inputs":[{"name":"bs"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"root","","",34,{"inputs":[{"name":"meta"},{"name":"self"}],"output":{"name":"self"}}],[11,"name","","",34,{"inputs":[{"name":"name"},{"name":"self"}],"output":{"name":"self"}}],[11,"art","","",34,{"inputs":[{"name":"art"}],"output":{"name":"self"}}],[11,"empty","","",34,{"inputs":[{"name":"meta"}],"output":{"name":"self"}}],[11,"singleton","","",34,{"inputs":[{"name":"meta"},{"name":"name"},{"name":"x"}],"output":{"name":"self"}}],[11,"extend","","",34,{"inputs":[{"name":"name"},{"name":"self"},{"name":"x"}],"output":{"name":"self"}}],[11,"hash","","",34,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"find","","",34,{"inputs":[{"name":"self"},{"name":"x"},{"name":"i64"}],"output":{"name":"option"}}],[11,"is_empty","","",34,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"split_atomic","","",34,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"elim","","",34,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"rootc"},{"name":"namec"}],"output":{"name":"res"}}],[11,"elim_arg","","",34,{"inputs":[{"name":"self"},{"name":"arg"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"rootc"},{"name":"namec"}],"output":{"name":"res"}}],[11,"elim_ref","","",34,{"inputs":[{"name":"self"},{"name":"nilc"},{"name":"leafc"},{"name":"binc"},{"name":"rootc"},{"name":"namec"}],"output":{"name":"res"}}],[11,"clone","adapton::engine::reflect::trace","",21,{"inputs":[{"name":"self"}],"output":{"name":"alloccase"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"changeflag"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"allockind"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"forcecase"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"effect"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"edge"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"trace"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","adapton::engine::reflect","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"val"}}],[11,"hash","","",14,null],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"val"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"val"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"const"}}],[11,"hash","","",15,null],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"const"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"const"}],"output":{"name":"bool"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"artcontent"}}],[11,"hash","","",16,null],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"artcontent"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"artcontent"}],"output":{"name":"bool"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"loc"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"loc"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",6,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"loc"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"effect"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"effect"}],"output":{"name":"bool"}}],[11,"hash","","",17,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"succ"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"succ"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"succ"}],"output":{"name":"bool"}}],[11,"hash","","",7,null],[11,"reflect","","",7,{"inputs":[{"name":"self"}],"output":{"name":"succ"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"pred"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"pred"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"pred"}],"output":{"name":"bool"}}],[11,"hash","","",8,null],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"compnode"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"compnode"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"compnode"}],"output":{"name":"bool"}}],[11,"hash","","",9,null],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"refnode"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"refnode"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"refnode"}],"output":{"name":"bool"}}],[11,"hash","","",10,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"purenode"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"purenode"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"purenode"}],"output":{"name":"bool"}}],[11,"hash","","",11,null],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"node"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"ne","","",18,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"hash","","",18,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"frame"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"dcg"}}],[14,"prog_pt","adapton","",null,null],[14,"thunk","","",null,null],[14,"memo","","",null,null],[14,"eager","","",null,null],[14,"cell_call","","",null,null]],"paths":[[3,"ProgPt"],[3,"Flags"],[3,"DCG"],[3,"Cnt"],[4,"Engine"],[4,"ArtIdChoice"],[3,"Loc"],[3,"Succ"],[3,"Pred"],[3,"CompNode"],[3,"RefNode"],[3,"PureNode"],[3,"Frame"],[3,"DCG"],[4,"Val"],[4,"Const"],[4,"ArtContent"],[4,"Effect"],[4,"Node"],[3,"Edge"],[3,"Trace"],[4,"AllocCase"],[4,"ChangeFlag"],[4,"AllocKind"],[4,"ForceCase"],[4,"Effect"],[8,"Reflect"],[3,"Name"],[3,"Art"],[4,"Dir2"],[4,"List"],[4,"Tree"],[4,"NameElse"],[3,"Meta"],[4,"Trie"],[8,"MetaT"],[8,"TrieIntro"],[8,"TrieElim"],[8,"SetIntro"],[8,"SetElim"],[3,"Punc"],[4,"Tree"],[4,"Dir"],[4,"Edit"],[3,"Zip"],[8,"ListIntro"],[8,"ListElim"],[8,"RoseIntro"],[8,"RoseElim"],[8,"Level"],[8,"TreeIntro"],[8,"TreeElim"],[8,"MapIntro"],[8,"MapElim"],[8,"SetIntro"],[8,"SetElim"]]};
initSearch(searchIndex);
