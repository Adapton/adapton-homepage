initSidebarItems({"fn":[["class_of_dcg_node",""],["div_of_alloc_tree",""],["div_of_dcg_alloc_edge",""],["div_of_dcg_force_edge",""],["div_of_dcg_succs",""],["div_of_edge",""],["div_of_force_tree",""],["div_of_loc",""],["div_of_name",""],["div_of_oploc",""],["div_of_path",""],["div_of_succ",""],["div_of_trace",""],["div_of_value_tree",""],["style_string",""],["write_cr",""],["write_dcg_edge_tree",""],["write_dcg_tree",""],["write_lab_name",""],["write_lab_results",""],["write_lab_results_summary",""],["write_sample_dcg",""]],"struct":[["Div","The `Div` struct represents a restricted form of a `<div>` element in HTML.  The field `tag` is a string, which corresponds to a distinguished `tag` CSS class that indicates the Rust datatype reflected into this `Div`.  The other CSS `classes` hold bits that signal various subcases (e.g., of `enum`s in the `reflect` module).  For Rust structures that have subfields and/or substructure, the `Div`'s `extent` field lists their reflections into `Div`s.  In principle, the produced `Div` structure has an equivalent amount of information to the corresponding Rust datatype, and could be \"parsed\" back into this Rust datatype later (let's not do that, though!).  The text field is useful for `Div` versions of `Name`s, for giving the text of the name."]],"trait":[["WriteHTML",""]]});